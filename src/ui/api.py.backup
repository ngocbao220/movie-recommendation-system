from fastapi import FastAPI, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
from fastapi.middleware.cors import CORSMiddleware

import pandas as pd
import os
import httpx
import asyncio
import sys

# Thư mục chứa api.py → src/ui
BASE_DIR = os.path.dirname(os.path.abspath(__file__))

# Lùi 2 cấp: ui → src → project root
PROJECT_ROOT = os.path.abspath(os.path.join(BASE_DIR, "..", ".."))

# Thêm project root vào sys.path để import models
sys.path.insert(0, PROJECT_ROOT)

# data/ nằm ở project root - Sử dụng links.csv để lấy tmdbId
DATA_PATH = os.path.join(PROJECT_ROOT, "data", "links.csv")
MOVIES_PATH = os.path.join(PROJECT_ROOT, "data", "movies.csv")

df_map = pd.read_csv(DATA_PATH)
# Bỏ các dòng có tmdbId = NaN
df_map = df_map.dropna(subset=['tmdbId'])
df_map["tmdbId"] = df_map["tmdbId"].astype(int)
movieId_to_tmdb = dict(zip(df_map["movieId"], df_map["tmdbId"]))

# Load movies.csv để mapping movieId -> title
df_movies = pd.read_csv(MOVIES_PATH)
movieId_to_title = dict(zip(df_movies["movieId"], df_movies["title"]))
title_to_movieId = {v: k for k, v in movieId_to_title.items()}

# Import Model 1 (Association Rules)
try:
    from models.model_1_rules.infer import AssociationRecommender
    association_model = AssociationRecommender()
    print("✅ Model 1 (Association Rules) loaded successfully!")
except Exception as e:
    association_model = None
    print(f"⚠️ Model 1 không khả dụng: {e}")

TMDB_API_KEY = "ff48b02cdcd1f6e40df93cb3ff292031"
BASE_URL = "https://api.themoviedb.org/3"

# FastAPI app
app = FastAPI()

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Mount static
app.mount("/static", StaticFiles(directory=BASE_DIR), name="static")

@app.get("/")
def index():
    return FileResponse(os.path.join(BASE_DIR, "test.html"))

# ---------------- Async TMDB requests ---------------- #

async def tmdb_get_movie(client: httpx.AsyncClient, tmdb_id: int):
    res = await client.get(
        f"{BASE_URL}/movie/{tmdb_id}",
        params={
            "api_key": TMDB_API_KEY,
            "language": "vi-VN",
            "append_to_response": "images"
        },
        timeout=15.0
    )
    return res.json()

async def tmdb_get_trailer_key(client: httpx.AsyncClient, tmdb_id: int):
    res = await client.get(
        f"{BASE_URL}/movie/{tmdb_id}/videos",
        params={
            "api_key": TMDB_API_KEY,
            "language": "en-US"
        },
        timeout=15.0
    )
    data = res.json().get("results", [])

    for v in data:
        if v["site"] == "YouTube" and v["type"] == "Trailer":
            return v["key"]
    for v in data:
        if v["site"] == "YouTube":
            return v["key"]
    return None

async def parse_movie_detail(client: httpx.AsyncClient, tmdb_id: int):
    m = await tmdb_get_movie(client, tmdb_id)
    trailer_key = await tmdb_get_trailer_key(client, tmdb_id)

    return {
        "title": m.get("title"),
        "original_title": m.get("original_title") (chưa tích hợp Model 2)"""
    # Top phim phổ biến để demo
    return [1, 356, 296, 318, 593, 260, 480, 527, 150, 110]

def recommend_similar_movies(movie_id, k=5):
    """Tìm phim tương tự - Sử dụng Model 1 (Association Rules)"""
    
    # Nếu model chưa train hoặc không load được, dùng fallback
    if association_model is None or association_model.rules is None:
        print(f"⚠️ Model 1 chưa sẵn sàng, dùng dữ liệu mẫu")
        return [2, 34, 56, 78, 100]
    
    try:
        # Chuyển movieId sang tên phim
        if movie_id not in movieId_to_title:
            return []
        
        movie_title = movieId_to_title[movie_id]
        
        # Gọi model để lấy gợi ý
        results = association_model.recommend(movie_title, top_k=k)
        
        # Chuyển tên phim về movieId
        recommended_movie_ids = []
        for result in results:
            rec_title = result['movie']
            if rec_title in title_to_movieId:
                recommended_movie_ids.append(title_to_movieId[rec_title])
        
        return recommended_movie_ids[:k]
        
    except Exception as e:
        print(f"⚠️ Lỗi khi gọi Model 1: {e}")
        # Fallback về dữ liệu mẫu
            "poster": f"https://image.tmdb.org/t/p/w500{m['poster_path']}" if m.get("poster_path") else None,
        "backdrop": f"https://image.tmdb.org/t/p/w1280{m['backdrop_path']}" if m.get("backdrop_path") else None,
        "logo": (
            f"https://image.tmdb.org/t/p/w300{m['images']['logos'][0]['file_path']}"
            if m.get("images", {}).get("logos") else None
        )
    }

# ---------------- Recommendation ---------------- #

def recommend_for_user(user_id, k=10):
    """Gợi ý phim cho user - dùng dữ liệu mẫu tạm"""
    # Top phim phổ biến để demo
    return [1, 356, 296, 318, 593, 260, 480, 527, 150, 110]

def recommend_similar_movies(movie_id, k=5):
    """Tìm phim tương tự - dùng dữ liệu mẫu tạm"""
    # Phim tương tự demo
    return [2, 34, 56, 78, 100]

# ---------------- API endpoint ---------------- #

@app.get("/api/recommend/user/{user_id}")
async def get_user_recommendations(user_id: int):
    """API gợi ý phim cho user"""
    try:
        # Lấy danh sách movie_id gợi ý
        rec_movie_ids = recommend_for_user(user_id, k=10)
        
        # Chuyển sang tmdb_id
        rec_tmdb_ids = [movieId_to_tmdb[mid] for mid in rec_movie_ids if mid in movieId_to_tmdb]
        
        if not rec_tmdb_ids:
            return []
        
        # Lấy thông tin chi tiết từ TMDB
        async with httpx.AsyncClient() as client:
            tasks = [parse_movie_detail(client, tmdb_id) for tmdb_id in rec_tmdb_ids]
            results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # Lọc kết quả thành công
        movies = [r for r in results if not isinstance(r, Exception)]
        
        return movies
        
    except Exception as e:
        raise HTTPException(500, f"Error: {str(e)}")

@app.get("/api/movie/{movieId}")
async def movie_detail(movieId: int):
    """API xem chi tiết phim và phim liên quan"""
    if movieId not in movieId_to_tmdb:
        raise HTTPException(404, "Movie not found")

    tmdb_id = movieId_to_tmdb[movieId]

    # Lấy phim tương tự
    rec_movie_ids = recommend_similar_movies(movieId, k=5)
    rec_tmdb_ids = [movieId_to_tmdb[mid] for mid in rec_movie_ids if mid in movieId_to_tmdb]

    async with httpx.AsyncClient() as client:
        # Song song lấy phim chính + phim liên quan
        tasks = [parse_movie_detail(client, tmdb_id)]  # phim chính
        tasks += [parse_movie_detail(client, r_id) for r_id in rec_tmdb_ids]  # phim liên quan

        results = await asyncio.gather(*tasks, return_exceptions=True)

    movie_detail_result = results[0]
    related_results = [r for r in results[1:] if not isinstance(r, Exception)]

    # Trả về frontend
    return {
        "movie": movie_detail_result,
        "related": related_results
    }


BASE_DIR = os.path.dirname(os.path.abspath(__file__))

# Mount thư mục ui để truy cập test.html
app.mount("/static", StaticFiles(directory=BASE_DIR), name="static")

@app.get("/")
def index():
    return FileResponse(os.path.join(BASE_DIR, "test.html"))

# tmdb_id = 862
# print(tmdb_get_movie(tmdb_id))
# print(tmdb_get_trailer_key(tmdb_id))